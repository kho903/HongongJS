# 5.2 함수 고급
- 자바스크립트는 '함수도 하나의 자료'라는 개념을 가지고 있어서 중간에 만들 수 있음. 
- 이는 2010년 전후로 등장한 비동기 프로그래밍을 이끔. 람다 또는 익명 함수라는 이름으로 기본 문법에 포함.

## 콜백 함수
- 자바스크립트는 함수도 하나의 자료형이므로 매개변수로 전달 가능. 매개변수로 전달하는 함수를 콜백(callback) 함수라 함
```js
function callThreeTimes(callback) {
    for (let i = 0; i < 3; i++) {
        callback(i);
    }
}

function print(i) {
    console.log(`${i}번째 함수 호출`)
}

callThreeTimes(print)
```
```text0번째 함수 호출
1번째 함수 호출
2번째 함수 호출
```
- callThreeTime() 함수는 함수를 매개변수로 받아 해당 함수를 3번 호출. 즉, 매개변수를 통해 함수를 받고, 그 함수를 통해 결과값을 호출함.
- 이를 익명 함수로 변경해보자.
```js
function callThreeTimes(callback) {
    for (let i = 0; i < 3; i++) {
        callback(i);
    }
}

callThreeTimes(function (i) {
    console.log(`${i}번째 함수 호출`)
})
```
```text
0번째 함수 호출
1번째 함수 호출
2번째 함수 호출
```
- 자바스크립트가 기본적으로 제공하는 함수 중에도 콜백 함수를 활용하는 함수가 많음. 어떠한 형태로 콜백 함수를 활용할까?

### 콜백 함수를 활용하는 함수 : forEach()
- 콜백 함수를 활용하는 가장 기본적인 함수는 forEach(). 배열이 갖고 있는 함수(매소드)로써 단순하게 배열 내부의 요소를 사용해서 콜백 함수를 호출해줌.
- 배열이 갖고 있는 메소드 중에서 콜백 함수를 활용하는 메소드는 다음과 같은 형태의 콜백 함수를 사용.
```js
function (value, index, array) { }
```
```js
const numbers = [273, 52, 103, 32, 57]

numbers.forEach(function (value, index, array) {
    console.log(`${index}번째 요소 : ${value}, 배열은 ${array}`)
});
```
```text
1번째 요소 : 52, 배열은 273,52,103,32,57
2번째 요소 : 103, 배열은 273,52,103,32,57
3번째 요소 : 32, 배열은 273,52,103,32,57
4번째 요소 : 57, 배열은 273,52,103,32,57
```

### 콜백 함수를 활용하는 함수 : map()
- map() 메소드도 배열이 갖고 있는 함수로 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만드는 함수.
```js
let numbers = [273, 52, 103, 32, 57]

numbers = numbers.map(function (value, index, array) {
    return value * value
});

numbers.forEach(console.log)
```
```text
74529 0 [ 74529, 2704, 10609, 1024, 3249 ]
2704 1 [ 74529, 2704, 10609, 1024, 3249 ]
10609 2 [ 74529, 2704, 10609, 1024, 3249 ]
1024 3 [ 74529, 2704, 10609, 1024, 3249 ]
3249 4 [ 74529, 2704, 10609, 1024, 3249 ]
```
- 배열의 모든 값을 제곱하여 다시 numbers에 담아주었고, forEach() 매개변수로 console.log 메소드 자체를 넘겨주어 출력하였음.
- 여기서 map 내에 익명함수의 매개변수를 value 하나만 써 주어도 됨. 사용하고자 하는 위치의 것만 순서에 맞춰 입력하면 됨.

### 콜백 함수를 활용하는 함수 : filter()
- filter() 메소드도 배열이 갖고 있는 함수로, 콜백 함수에서 리턴하는 값이 true인 것만 모아서 새로운 배열을 만드는 함수.
```js
const numbers = [0, 1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(function (value) {
    return value % 2 === 0;
});

console.log(`원래 배열 ${numbers}`)
console.log(`짝수만 추출한 배열 ${evenNumbers}`)
```
```text
원래 배열 0,1,2,3,4,5
짝수만 추출한 배열 0,2,4
```

## 화살표 함수
- 앞에서 살펴본 map(), filter() 함수처럼 단순한 형태의 콜백 함수를 쉽게 입력하고자 화살표(arrow) 함수라는 함수 생성 방법 존재.
- function 대신 화살표(=>)를 사용하며, 다음과 같은 형태로 생성하는 간단한 함수
```js
(매개변수) => {

}
```
- 다음과 같이 간편하게도 사용 가능.
```js
(매개변수) => 리턴값
```
- 내부에서 this 키워드가 지칭하는 대상이 다르다는 등의 미세한 차이가 존재.
- 예를 들어 이전의 map() 함수의 콜백 함수로 화살표 함수를 넣는다면 다음과 같이 코드 작성.
```js
const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(array.map((value) => value * value));
```
```text
[
   0,  1,  4,  9, 16,
  25, 36, 49, 64, 81
]
```
- filter(), map(), forEach() 메소드를 화살표 함수와 함께 연속적으로 사용해보자.
```js
let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
numbers
    .filter((value) => value % 2 === 0)
    .map((value) => value * value)
    .forEach((value) => {
        console.log(value);
    })
```
```text
0
4
16
36
64
```

## 타이머 함수
- js에는 특정 시간마다 또는 특정 시간 이후에 콜백 함수를 호출할 수 있는 타이머(timer) 함수들이 존재. 이 함수로 시간과 관련된 처리 가능.
  - setTimeout(함수, 시간) : 특정 시간 후에 함수를 한 번 호출함.
  - setInterval(함수, 시간) : 특정 시간마다 함수를 호출함.
```js
setTimeout(() => {
    console.log('1초 후에 실행됩니다.');
}, 1 * 1000);

let count = 0;
setInterval(() => {
    console.log(`1초마다 실행됩니다. ${count} 번째`);
    count++;
}, 1 * 1000);
```
```text
1초 후에 실행됩니다.
1초마다 실행됩니다. 0 번째
1초마다 실행됩니다. 1 번째
1초마다 실행됩니다. 2 번째
1초마다 실행됩니다. 3 번째
1초마다 실행됩니다. 4 번째
...
```
- setTimeout() 함수와 setInterval() 함수를 사용해서 특정 시간 후에 코드를 호출함.
- 코드를 실행하면 1초 후에 setTimeout() 함수의 콜백 함수가 실행되고, 1초마다 setInterval() 함수의 콜백 함수가 실행되는 것을 볼 수 있음.
- 타이머를 종료하고 싶을 때는 clearTimeout(), clearIntervcal() 함수를 사용
    - clearTimeout(타이머_ID) : setTimeout() 함수로 설정한 타이머를 제거함.
    - clearInterval(타이머_ID) : setInterval() 함수로 설정한 타이머를 제거함.
- 타이머_ID는 setTimeout(), setInterval() 호출시 리턴값으로 나오는 숫자.
```js
let id
let count = 0
id = setInterval(() => {
    console.log(`1초마다 실행됩니다. ${count} 번째`)
    count++
}, 1 * 1000)

setTimeout(() => {
    console.log('타이머를 종료합니다.')
    clearInterval(id)
}, 5 * 1000)
```
```text
1초마다 실행됩니다. 0 번째
1초마다 실행됩니다. 1 번째
1초마다 실행됩니다. 2 번째
1초마다 실행됩니다. 3 번째
타이머를 종료합니다.
```

## 즉시 호출 함수
- 여러 웹 사이트의 js 코드를 보면 다음과 같이 익명 함수를 생성하고 곧바로 즉시 호출하는 패턴을 많이 볼 수 있음. 이런 코드는 왜 사용할까?
```js
(function () { }) ()
```
- 일반적으로 js는 HTML 페이지 내부에서 사용할 때 script 태그를 여러 개 사용하고 코드를 입력함.
- 코드가 여러 곳에서 사용되면 변수 이름 충돌 가능성이 높음. 예를 들어 다음 코드를 보자.
```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>immediately</title>
</head>
<!-- 다른 곳에서 가져온 자바스크립트 코드 -->
<script>
    let pi = 3.14
    console.log(`파이 값은 ${pi}입니다.`)
</script>
<!-- 내가 만든 자바스크립트 코드 -->
<script>
    let pi = 3.141592
    console.log(`파이 값은 ${pi}입니다.`)
</script>
</html>
```
```text
파이 값은 3.14입니다.
Uncaught SyntaxError: Identifier 'pi' has already been declared
```
- 식별자가 이미 사용되고 있다는 오류를 발생하면서 내가 만든 자바스크립트 코드는 실행되지 않음.
- 변수가 존재하는 범위를 스코프(scope)라고 부르는데, 이 스코프는 같은 단계에 있을 경우 무조건 충돌이 일어남.
- 자바스크립트에서 이러한 스코프 단계를 변경하는 방법은 중괄호를 사용해서 블록을 만들거나, 함수를 생성해서 블록을 만드는 방법.
```js
let pi = 3.14
console.log(`파이 값은 ${pi}입니다.`)

// 블록을 사용한 스코프 생성
{
    let pi = 3.141592
    console.log(`파이 값은 ${pi}입니다.`)
}
console.log(`파이 값은 ${pi}입니다.`)

// 함수 블록을 사용한 스코프 생성
function sample() {
    let pi = 3.1415
    console.log(`파이 값은 ${pi}입니다.`)
}
sample()
console.log(`파이 값은 ${pi}입니다.`)
```
```text
파이 값은 3.14입니다.
파이 값은 3.141592입니다.
파이 값은 3.14입니다.
파이 값은 3.1415입니다.
파이 값은 3.14입니다.
```
- 코드를 실행하면 블록 내부에서는 변수 pi를 출력했을 때 3.141592, 함수 블록 내부에서는 3.1415 블록 외부에서는 3.14 가 출력됨. 이름 충돌이 발생하지 않음.
- 이렇게 블록 내부에서 같은 이름으로 변수를 선언하면 변수가 외부 변수와 충돌하지 않고 외부 변수를 가림. 내부 블록에서는 내부 블록에서 선언한 변수만 볼 수 있음.
- 이렇게 블록이 다른 경우 내부 변수가 외부 변수를 가리는 현상을 섀도잉(shadowing)이라고 부름.

## 즉시 호출 함수 문제 해결하기
- 블록을 사용하는 방법과 함수 블록을 사용해 변수 충돌을 막는 방법 모두 최신 js에서 지원.
- 구 버전에서는 변수를 선언할 때 사용할 때 사용하던 var 키워드는 함수 블록을 사용하는 경우에만 변수 충돌을 막을 수 있음.
- 지금도 구 버전을 대응해야 하는 경우가 많고, Babel 등 최신 버전의 js를 구 버전으로 변경해주는 트랜스파일러도 단순한 블록으로 함수 충돌을 막는 코드는 제대로 변환 불가.
- 그래서 많은 개발자들이 함수 블록을 사용해 이런 문제를 해결함. 충돌 문제를 해결하기 위해 사용하는 것이므로 함수를 만들자마자 즉시 호출할 수 있도록 다음과 같이 작성.
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>immediately</title>
</head>
<!-- 다른 곳에서 가져온 자바스크립트 코드 -->
<script>
  let pi = 3.14
  console.log(`파이 값은 ${pi}입니다.`)
</script>
<!-- 내가 만든 자바스크립트 코드 -->
<script>
  (function () {
    let pi = 3.141592
    console.log(`파이 값은 ${pi}입니다.`)
  }) ()
</script>
</html>
```

## 엄격 모드
- 여러 js 코드를 보면 가장 위쪽에 'use strict'라는 문자열이 등장함. 엄격 모드(strict) 기능으로 js는 이러한 문자열을 읽어들인 순간부터 코드를 엄격하게 검사함.
```js
'use strict'
문장 
문장
```
- data라는 변수를 let 키워드 등으로 선언하지 않고 곧바로 사용한다.
```js
data = 10;
console.log(data)
```
```text
10
```
- 하지만 엄격 모드에서는 오류 발생.
```js
'use strict'
data = 10;
console.log(data)
```
```text
data = 10;
     ^

ReferenceError: data is not defined
```
- js는 오류를 어느 정도 무시하고 넘어가는 것들이 있어 편하지만 실수로 이어지기도 함.
- 일반적으로 엄격 모드를 사용하는 것이 좋음. 엄격 모드에서 발생하는 오류에 대해서는 모질라 엄격 모드 문서를 참고.
- 즉시 호출 함수를 만들고, 이 블록의 가장 위쪽에서 엄격 모드를 적용하는 경우가 많음. 이렇게 하면 해당 블록 내부에만 엄격 모드가 적용됨.
```js
(function () {
    'use strict'
    문장
    문장
})()
```

## 익명 함수와 선언적 함수의 차이
- while 반복문과 for 반복문은 2가지 모두 많이 사용되지만, 사용하는 상황이 조금씩 다름.
- while 문은 조건을 중심으로, for문은 횟수를 중심으로 또는 배열을 중심으로 반복할 때 사용.
- 그런데 익명 함수와 선언적 함수는 사용하는 상황이 비슷. 익명 함수를 보통 선호하는 편. 왜 익명함수가 더 안전한지 알아보자.

### 익명 함수의 사용
- 익명 함수는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성됨. 따라서 다음과 같은 코드가 있다면 위에서 아래로 차례대로 코드가 실행되면서 익명 함수라는
변수에 '2번째 익명 함수입니다.'를 호출하는 함수가 할당됨.
```js
let 익명함수

익명함수 = function () {
    console.log('1번째 익명 함수입니다.')
};

익명함수 = function () {
    console.log('2번째 익명 함수입니다.')
};
익명함수()
```
```text
2번째 익명 함수입니다.
```

### 선언적 함수 호출
- 선언적 함수는 순차적인 코드 실행이 일어나기 전에 생성됨. 따라서 선언적 함수는 같은 블록이라면 어디에서 함수를 호출해도 상관 없음.
```js
선언적함수()

function 선언적함수() {
    console.log('1번째 선언적 함수입니다.')
}

function 선언적함수() {
    console.log('2번째 선언적 함수입니다.')
}
```
```text
2번째 선언적 함수입니다.
```
- 또한 선언적 함수도 입력한 순서대로 생성되고 같은 이름이라면 덮어쓰므로 코드를 실행했을 때 "2번째 선언적 함수입니다."가 출력됨.

### 선언적 함수와 익명 함수의 조합
```js
함수()

함수 = function () {
    console.log('익명 함수입니다.')
}

function 함수() {
    console.log('선언적 함수입니다.')
}

함수()
```
```text
선언적 함수입니다.
익명 함수입니다.
```

### 블록이 다른 경우에 선언적 함수의 사용
- 선언적 함수는 어떤 블록을 읽어들일 때 먼저 생성됨.
```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>otherblockDeclared.html</title>
</head>

<script>
    선언적함수()

    function 선언적함수() {
        console.log('1번째 선언적 함수입니다.')
    }
</script>

<script>
    function 선언적함수() {
        console.log('2번째 선언적 함수입니다.')
    }
</script>
<script>
    선언적함수()
</script>

</html>
```
```text
1번째 선언적 함수입니다.
2번째 선언적 함수입니다.
```
- 이처럼 블록이 나뉘어진 경우에는 선언적 함수의 실행 흐름을 예측하는 것이 훨씬 힘들어짐.
- 다른 프로그래밍 언어들은 일반적으로 선언적 함수 형태로 함수를 많이 사용하지만, js는 이처럼 블록이 예상하지 못하게 나뉘는 문제 등이 발생할 수 있어 안전을 위해
익명 함수를 더 많이 사용하는 편.
- 과거 자바스크립트는 var 키워드로 변수를 선언했음. var 키워드는 이전 코드처럼 덮어쓰는 문제가 발생.
- 하지만 현대의 js는 let 키워드와 const 키워드로 변수와 상수를 선언함. 그리고 이러한 키워드들은 위험을 원천적으로 차단하기 위해서 오류를 발생시킴.
```js
let 함수 = function () {
  console.log('익명 함수입니다.')
};

function 함수() {
  console.log('선언적 함수입니다.')
}
함수()
```
```text
function 함수() {
^

SyntaxError: Identifier '함수' has already been declared
```
- 따라서 한 가지로 통일해서 사용하는 것이 오류의 위험을 줄일 수 있고, 통일한다면 익명 함수로 통일해서 사용하는 것이 안전을 위해서 더 편한 선택.

## 정리
- 콜백 함수란 매개변수로 전달하는 함수를 의미함.
- 화살표 함수란 익명 함수를 간단하게 사용하기 위한 목적으로 만들어진 함수 생성 문법. () => {} 형태로 함수를 만들고, 리턴값만을 가지는 함수라면 () => 값 형태로 사용 가능.
- 즉시 호출 함수란 변수의 이름 충돌을 막기 위해서 코드를 안전하게 사용하는 방법.
- js의 문법 오류를 더 발생시키는 엄격 모드는 실수를 줄일 수 있는 방법. 'use strict'라는 문자열을 블록 가장 위쪽에 배치해서 사용 가능.
