# 7.2 이벤트 활용
## 이벤트 모델
- 이벤트를 연결하는 방법을 이벤트 모델(event model)이라 부름.
- 앞에서 살펴본 addEventListener() 메소드가 현재 표준으로 사용하고 있는 방법으로, 표준 이벤트 모델이라 부름.
```js
document.body.addEventListener('keyup', () => {
    
})
```
- 과거에는 다음과 같이 문서 객체가 갖고 있는 onOO 으로 시작하는 속성에 함수를 할당해 이벤트를 연결함. 이와 같은 이벤트 연결 방법을 고전 이벤트 모델이라 부름.
```js
document.body.onkeyup = (event) => {
    
}
```
- 그리고 고전 이베느 모델처럼 onOO으로 시작하는 속성을 HTML 요소에 직접 넣어서 이벤트를 연결하는 것을 인라인 이벤트 모델이라 부름.
```html
<script>
    const listener = (event) => {
        
    }
</script>
<body onkeyup="listener(event)">

</body>
```
- 인라인 이벤트 모델은 HTML 요소의 onOO속성에 js 코드를 넣는 것. 현재 코드에서는 listener()라는 함수를 호출하고 있음. 이때 onOO 속성 내부에서 변수 event를 활용 가능. 이 변수를 listener() 함수의 매개변수로 전달함.
- 모든 이벤트 모델의 이벤트 리스너는 첫 번째 매개변수로 이벤트 객체(event object)를 받음. 이벤트 객체에는 이벤트와 관련된 정보가 들어있음. 웹 브라우저에는 많은 이벤트가 있으므로 이벤트를 모두 설명하는 것은 불가능.
- 초기의 웹(2000년 이전)은 인라인 이벤트 모델을 일반적으로 사용함. js의 활용이 많지 않아 간단한 코드를 넣게에 편리했기 때문.
- 시간이 지나고 js를 더 많이 활용하게 되면서 고전 이벤트 모델을 많이 사용(2010년 이전). 다만 고전 이벤트 모델은 이벤트 리스너 하나만 연결할 수 있다는 단점 존재.
- 그래서 표준 이벤트 모델이 등장해 이벤트 리스너를 여러 개 연결할 수 있게 되었고 표준 이벤트 모델을 현재 많이 사용하게 됨. 인라인 이벤트 모델은 2000년 이후로 거의 사용되지 않아 알아야 할 필요가 없는 이벤트 모델로 취급받기도 함.
- 하지만 최근 프론트엔드 프레임워크들이 인라인 이벤트 모델을 활용하는 형태로 코드를 작성해서 현재에는 인라인 이벤트 모델과 표준 이벤트 모델을 많이 사용.

## 키보드 이벤트
- 키보드 이벤트는 3가지 이벤트 존재.

| 이벤트      | 설명                                                                   |
|----------|----------------------------------------------------------------------|
| keydown  | 키가 눌릴 때 실행됨. 키보드를 꾹 누르고 있을 때도, 입력할 때도 실행됨.                           |
| keypress | 키가 입력되었을 때 실행됨. 하지만 웹 브라우저에 따라 아시아권 문자(한/중/일어)를 제대로 처리하지 못하는 문제가 존재. |
| keyup    | 키보드에서 키가 떨어질 때 실행됨.                                                  |

- keydown 이벤트와 keypress 이벤트는 웹 브라우저에 따라서 아시아권의 문자를 제대로 처리하지 못하는 문제가 있어서 일반적으로는 keyup을 사용함.
- 간단하게 키보드 이벤트로 입력 양식의 글자 수를 세는 프로그램을 만들어보자. 다음 프로그램은 textarea에 keyup 이벤트를 적용해서 입력한 글자 수를 세는 프로그램. textarea처럼 텍스트를 입력하는 입력 양식의 값은 value 속성으로 읽어들임.
```html
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')
        
        textarea.addEventListener('keyup', (event) => {
            const length = textarea.value.length
            h1.textContent = `글자 수: ${length}`
        })
    })
</script>
<body>
    <h1></h1>
    <textarea></textarea>
</body>
```
- 코드를 실행하고 입력 양식에 값을 입력하면 글자 수를 출력함.
- 참고로 키보드 이벤트의 문제를 간단하게 살펴보자. 위의 예제를 keydown 이벤트로 구현하면 상황에 따라서 글자 수를 제대로 세지 못한다는 문제 존재.
- 이어서 keypress 이벤트로 구현하면 아시아권의 문자는 공백(띄어쓰기, 줄바꿈 등)이 들어가기 전까지는 글자 수를 세지 않음. 아예 keypress 이벤트가 발생하지 않음.
- keyup도 문제가 한가지 존재. 키가 키보드에서 떨어질 때 발생하므로 특정 키를 꾹 누르고 있으면 글자 수를 세지 않음.
- 대표적인 SNS 트위터는 140 글자로 글자 수가 제한됨. 초기에 keypress로 글자 수를 세었는데, 위와 같은 문제로 아시아권 문자의 글자 수를 제대로 세지 못하는 문제가 발생. 여러 과정을 거쳐 현재는 키보드 이벤트를 사용하지 않고 글자 수를 셈.

### 키보드 키 코드 사용하기
- 키보드 이벤트가 발생할 때는 이벤트 객체로 어떤 키를 눌렀는지와 관련된 속성들이 따라옴. 여러 속성들이 있지만, 여기서는 다음 속성만 알아보자.

| 이벤트 속성 이름 | 설명             |
|-----------|----------------|
| code      | 입력한 키          |
| keyCode   | 입력한 키를 나타내는 숫자 |
| altKey    | alt 키를 눌렀는지    |
| ctrlKey   | Ctrl 키를 눌렀는지   |
| shiftKey  | Shift 키를 눌렀는지  |

- code 속성은 입력한 키를 나타내는 문자열이 들어있고, altKey, ctrlKey, shiftKey 속성은 해당 키를 눌렀는지 불 자료형 값이 들어있음.
- 다음 코드는 keydown 이벤트와 keyup 이벤트가 발생할 때 표에서 설명한 속성을 모두 출력하는 프로그램.
```html
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const h1 = document.querySelector('h1')
        const print = (event) => {
            let output = ''
            output += `alt: ${event.altKey}<br>`
            output += `ctrl: ${event.ctrlKey}<br>`
            output += `shift: ${event.shiftKey}<br>`
            output += `code: ${typeof(event.code) !== 'undefined' ?
                    event.code : event.keyCode}<br>`
            h1.innerHTML = output
        }

        document.addEventListener('keydown', print)
        document.addEventListener('keyup', print)
    })
</script>
<body>
    <h1></h1>
</body>
```
- 코드를 실행하고 키보드를 눌러 보자. 예를들어 alt, ctrl, shift 키를 누른 상태라면 모두 true 그리고 마지막으로 누른 키가 code에 출력됨. 페이스북과 트위터 등과 같은 SNS는 여러 단축키 사용 가능. 이러한 단축키를 구현할 때 키보드 이벤트 속성 사용.
- 코드에서 `event.code`가 있는 경우를 확인하는 코드를 사용했는데, 이는 인터넷 익스플로러와 구 버전의 엣지 브라우저를 지원하기 위함. 그런데 인터넷 익스플로러와 구버전의 엣지 브라우저는 code 속성을 지원하지 않아 keyCode 속성을 활용해 프로그램을 구현해야 함.
- code 속성값
```text
https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
```
- keyCode 속성 값
```text
https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
```
- keyCode 속성을 활용한 예제도 살펴보자. keyCode 속성은 입력한 키를 숫자로 나타냄. 37, 38, 39, 40이 방향키 왼쪽 위 오른쪽 아래를 나타냄. 이를 활용해서 화면에 별을 출력하고 이동하는 프로그램을 구현하면 다음과 같음.
```html
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // 별의 초기 설정
        const star = document.querySelector('h1')
        star.style.position = 'absolute' // style 속성을 조작해 position 값을 설정함.
        
        // 별의 이동을 출력하는 기능
        let [x, y] = [0, 0]
        const block = 20
        const print = () => {
            star.style.left = `${x * block}px`
            star.style.top = `${y * block}px`
        }
        print()
        
        // 별을 이동하는 기능
        const [left, up, right, down] = [37, 38, 39, 40] // 방향키 keyCode (키 코드)를 쉽게 사용할 수 있게 변수를 사용해 이름을 붙임.
        document.body.addEventListener('keydown', (event) => {
            switch (event.keyCode) {
                case left:
                    x -= 1
                    break
                case up:
                    y -= 1
                    break
                case right:
                    x += 1
                    break
                case down:
                    y += 1
                    break
            }
            print()
        })
    })
</script>
<body>
    <h1>★</h1>
</body>
```
- 한국어 처리 때문에 keyup 이벤트를 많이 사용하지만, 방향키는 처리 문제가 없으므로 다른 이벤트를 활용해도 됨. 방향키를 사용하는 게임 등을 할 때는 방향키를 꾹 누르고 있을 가능성이 많으므로 keyDown 이벤트를 활용했음.
- 코드를 실행하고 방향키를 누르면 별이 이동하는 것을 볼 수 있음.
- 참고로 인터넷 익스플로러를 지원하려고 keyCode 속성을 사용했는데, 애초에 const 키워드와 let 키워드 등은 인터넷 익스플로러에서 작동하지 않음. 이럴 때 코드를 바벨이라는 트랜스파일러에 넣기만 하면 인터넷 익스플로러에서 동작할 수 있는 코드로 변환함.
- 바벨이 기본적인 문법은 변환하지만, code 속성과 keyCode 속성 등까지 변환하지는 못하므로 어떤 속성이 인터넷 익스플로러에서 사용할 수 있는지 없는지는 따로 기억해 두어야 함.

## 이벤트 발생 객체
- 지금까지는 이벤트 내부에서 문서 객체 변수를 사용해 문서 객체와 관련된 정보를 추출했음.
- 이전에 사용했던 코드
```html
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // textarea는 문서 객체 변수로 문서 객체의 value 속성을 추출함.
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')
        
        textarea.addEventListener('keyup', (event) => {
            const length = textarea.value.length
            h1.textContent = `글자 수: ${length}`
        })
    })
</script>
```
- 그런데 상황에 따라서는 이벤트 리스너 내부에서 그러한 변수에 접근할 수 없는 경우가 존재. 예를 들어 다음 코드에서는 listener() 함수 내부에서 textarea 변수에 접근할 수 없어 오류 발생.
- 이벤트 리스터를 외부로 빼낸 경우
```html
<script>
    const listener = (event) => {
        const length = textarea.value.length // 현재 블록에서는 textarea 변수를 사용할 수 없음.
        h1.textContent = `글자 수: ${length}`
    }
    
    document.addEventListener('DOMContentLoaded', () => { // 이벤트 리스터가 외부로 분리됨.
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')
        textarea.addEventListener('keyup', listener)
    })
</script>
```
- 코드의 규모가 커지면 이처럼 이벤트 리스너를 외부로 분리하는 경우가 많아짐. 이러한 경우에는 이벤트를 발생시킨 객체(현재 코드의 textarea)에 어떻게 접근할 수 있을까?
- 2가지 방법으로 문제 해결 가능.
1. event.currentTarget 속성을 사용함
- 이는 `() => {}`와 `function() {}` 모두 사용 가능.
2. this 키워드를 사용함.
- 화살표 함수가 아닌 `function() {}` 형태로 함수를 선언한 경우에 사용함.


- 화살표 함수가 없었던 과거에는 2번 방법을 많이 사용했음. 하지만 화살표 함수가 등장한 이후로는 2가지 방법 모두 많이 사용함. 
- 라이브러리와 프레임워크에 따라서 선호하는 형태가 다름. 라이브러리와 프레임워크를 사용할 경우에는 해당 라이브러리와 프레임워크의 문서를 살펴보면서 어떤 형태가 더 일반적으로 사용되는 지 확인하고 활용 필요.
- event.currentTarget을 사용하는 경우는 다음과 같음.
```html
<script>
    const listener = (event) => {
        const length = event.currentTarget.value.length
        h1.textContent = `글자 수: ${length}`
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')
        textarea.addEventListener('keyup', listener)
    })
</script>
```
- 이어서 this 키워드를 사용하는 경우는 다음과 같음.
```html
<script>
    const listener = function (event) {
        const length = this.value.length
        h1.textContent = `글자 수: ${length}`
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')
        textarea.addEventListener('keyup', listener)
    })
</script>
```
