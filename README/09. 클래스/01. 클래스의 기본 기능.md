# 9.1 클래스의 기본 기능
- 많은 프로그래밍 언어에서 객체 지향 (Object Oriented)이라는 패러다임을 기반으로 만들어짐. 객체를 우선적으로 생각해서 프로그램을 만든다는 방법론.
- 객체 지향 프로그래밍에 언어들은 클래스(class)라는 문법으로 객체(object)를 효율적이고 안전하게 만들어 객체 지향 패러다임을 쉽게 적용하도록 도와줌.

## 추상화
- 현재 만들어지고 있는 대부분의 프로그램은 "우리가 어떤 데이터를 활용하는가?"라는 생각으로부터 시작됨.
- 현실의 객체는 수많은 속성을 가지고 있고 그 속성들이 모두 데이터가 될 수 있음. 사람을 예로 들면 키, 몸무게, 얼굴 둘레, 눈썹 길이, 눈 크기, 코 크기, 입 크기, 머리카락 개수 등등 모두 가능. 그렇기 때문에 현실에 존재하는
모든 정보를 완벽하게 컴퓨터 내부에 입력하는 것은 불가능에 가까움.
- 그러나 다행히 프로그램을 만들 때 그러한 것이 모두 필요하지는 않음. 병원에서 사용하는 업무 프로그램을 만든다면 의사, 간호사, 환자, 병식, 예약 기록, 진료 기록, 입퇴원 기록과 같은 정보가 필요하고, 그 중에서 환자 정보를
사용한다면 환자 이름, 생년월일, 성별, 연락처 등만 알면 됨.
- 이와 같이 프로그램에 필요한 요소만 사용해서 객체를 표현하는 것을 추상화(abstraction)이라 부름. 포괄적인 의미로는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념과 기능을 간추려내는 것을 추상화라 함.

## 같은 형태의 객체 만들기
- 학생 성적 관리 프로그램을 만든다고 할 때, 학생이라는 객체가 필요하고, 그러한 학생들로부터 성적 관리에 필요한 공통사항을 추출하는데, 이를 추상화라 함.
- 학생들이 여러 명이므로 추출한 요소는 배열을 이용해 관리함.
- 이를 간단하게 코드로 작성하면 다음과 같음.
- 객체와 배열 조합하기
```js
// 객체를 선언함.
const students = []
students.push({ 이름: '구름', 국어: 87, 영어: 98, 수학: 88, 과학: 90 })
students.push({ 이름: '별이', 국어: 92, 영어: 98, 수학: 96, 과학: 88 })
students.push({ 이름: '겨울', 국어: 76, 영어: 76, 수학: 94, 과학: 86 })
students.push({ 이름: '바다', 국어: 98, 영어: 98, 수학: 98, 과학: 92 })

// 출력
console.log(JSON.stringify(students, null, 2))
```
```text
[
  {
    "이름": "구름",
    "국어": 87,
    "영어": 98,
    "수학": 88,
    "과학": 90
  },
  {
    "이름": "별이",
    "국어": 92,
    "영어": 98,
    "수학": 96,
    "과학": 88
  },
  {
    "이름": "겨울",
    "국어": 76,
    "영어": 76,
    "수학": 94,
    "과학": 86
  },
  {
    "이름": "바다",
    "국어": 98,
    "영어": 98,
    "수학": 98,
    "과학": 92
  }
]
```
- 여기에서 각각의 객체에 학생들의 성적 총합과 평균을 구하는 기능을 추가해보면, 다음과 같이 반복문을 돌리고, 내부에서 성적의 총합을 구하고, 이를 기반으로 평균을 구하면 됨.
- 객체 활용하기 코드
```js

const students = []
students.push({ 이름: '구름', 국어: 87, 영어: 98, 수학: 88, 과학: 90 })
students.push({ 이름: '별이', 국어: 92, 영어: 98, 수학: 96, 과학: 88 })
students.push({ 이름: '겨울', 국어: 76, 영어: 76, 수학: 94, 과학: 86 })
students.push({ 이름: '바다', 국어: 98, 영어: 98, 수학: 98, 과학: 92 })

// 출력
let output = '이름\t총점\t평균\n'
for (const s of students) {
    const sum = s.국어 + s.영어 + s.수학 + s.과학
    const average = sum / 4
    output += `${s.이름}\t${sum}점\t${average}점\n`
}
console.log(output)
```
```text
이름    총점    평균
구름    363점   90.75점
별이    374점   93.5점
겨울    332점   83점
바다    386점   96.5점
```

## 객체를 처리하는 함수
- 성적 총합을 구하는 기능과 평균을 구하는 기능은 여러 프로그램에서 활용될 수 있음. 따라서 단순하게 계산하는 것보다 함수로 만들어 놓으면 확장성을 고려했을 떄 좋은 방법.
- getSumOf() 와 getAverageOf() 라는 이름으로 함수를 만들고, 매개변수로 학생 객체를 받아 총합과 평균을 구하는 프로그램을 만들자.
```js
const students = []
students.push({ 이름: '구름', 국어: 87, 영어: 98, 수학: 88, 과학: 90 })
students.push({ 이름: '별이', 국어: 92, 영어: 98, 수학: 96, 과학: 88 })
students.push({ 이름: '겨울', 국어: 76, 영어: 76, 수학: 94, 과학: 86 })
students.push({ 이름: '바다', 국어: 98, 영어: 98, 수학: 98, 과학: 92 })

// 객체를 처리하는 함수 선언.
function getSumOf(student) {
    return student.국어 + student.영어 + student.수학 + student.과학
}

function getAverageOf(student) {
    return getSumOf(student) / 4
}

// 출력
let output = '이름\t총점\t평균\n'
for (const s of students) {
    output += `${s.이름}\t${getSumOf(s)}점\t${getAverageOf(s)}점\n`
}
console.log(output)
```
```text
이름    총점    평균
구름    363점   90.75점
별이    374점   93.5점
겨울    332점   83점
바다    386점   96.5점
```
- 전체적인 코드는 길어졌지만, 객체를 만드는 부분과 객체를 활용하는 부분으로 나눔. 이렇게 코드를 분할하면 객체에 더 많은 기능을 추가하게 되었을 때 객체를 쉽게 유지보수할 수 있으며, 객체를 활용할 때도 더 간단하게 코드
작성 가능.

## 객체의 기능을 메소드로 추가하기
- 현재 코드에서는 객체가 학생 객체 하나이므로 이렇게 코드를 작성해도 문제가 없지만, 객체의 수가 늘어나면 함수 이름 충돌 발생 가능. 또한 매개변수에 어떤 종류의 객체를 넣을지 몰라 함수를 사용하는데 혼동이 있을 수 있음.
- 그래서 함수를 메소드로써 객체 내부에 넣어서 활용하는 방법을 사용하기 시작함. 다음과 같이 반복문을 사용해 모든 객체에 getSum() 메소드와 getAverage() 메소드를 추가해보자.
```js

const students = []
students.push({ 이름: '구름', 국어: 87, 영어: 98, 수학: 88, 과학: 90 })
students.push({ 이름: '별이', 국어: 92, 영어: 98, 수학: 96, 과학: 88 })
students.push({ 이름: '겨울', 국어: 76, 영어: 76, 수학: 94, 과학: 86 })
students.push({ 이름: '바다', 국어: 98, 영어: 98, 수학: 98, 과학: 92 })

// students 배열 내부의 객체 모두에 메소드를 추가함.
for (const student of students) {
    student.getSum = function () {
        return this.국어 + this.영어 + this.수학 + this.과학
    }

    student.getAverage = function () {
        return this.getSum() / 4
    };
}

// 출력
let output = '이름\t총점\t평균\n'
for (const s of students) {
    output += `${s.이름}\t${s.getSum()}점\t${s.getAverage()}점\n`
}
console.log(output)
```
```text
이름    총점    평균
구름    363점   90.75점
별이    374점   93.5점
겨울    332점   83점
바다    386점   96.5점
```
- 이렇게 코드를 작성하면 함수 이름 충돌도 발생하지 않고, 함수를 잘못 사용하는 경우도 줄일 수 있음.
- 지금까지의 코드는 객체의 키와 값을 하나하나 모두 입력해서 생성함. 만약 함수를 사용해서 객체를 찍어내면 어떨까? 함수만 만들면 객체를 좀 더 손쉽게 생성할 수 있음.
- 객체를 생성하는 함수
```js
function createStudent(이름, 국어, 영어, 수학, 과학) {
    return {
        // 속성을 선언함.
        이름: 이름,
        국어: 국어,
        영어: 영어,
        수학: 수학,
        과학: 과학,

        // 메소드를 선언함.
        getSum() {
            return this.국어 + this.영어 + this.수학 + this.과학
        },
        getAverage() {
            return this.getSum() / 4
        },
        toString() {
            return `${this.이름}\t${this.getSum()}점\t${this.getAverage()}점\n`
        }
    }
}

// 객체를 선언함.
const students = []
students.push(createStudent('구름', 87, 98, 88, 90))
students.push(createStudent('별이', 92, 98, 96, 88))
students.push(createStudent('겨울', 76, 96, 94, 86))
students.push(createStudent('바다', 98, 52, 98, 92))

// 출력
let output = '이름\t총점\t평균\n'
for (const s of students) {
    output += s.toString()
}
console.log(output)
```
- createStudent() 함수를 만들고, 여기에 객체를 만들어 리턴하게 만듦.
- 이렇게 함수를 만들면 여러 가지 이득 발생. 객체를 하나하나 만들 때와 비교해서
  - 오탈자의 위험이 줄어듦.
  - 코드를 입력하는 양이 크게 줄어듦.
  - 마지막으로 속성과 메서드를 한 함수 내부에서 관리할 수 있으므로 객체를 더 손쉽게 유지보수할 수 있음.
- 그런데 현재 코드에는 눈에 보이지 않는 문제 존재. 객체별로 getSum(), getAverage(), toString() 메소드를 생성하므로 함수라는 기본 자료형보다 무거운 자료형이 여러 번 생성됨.

## 클래스 선언하기
- 객체들을 정의하고 그러한 객체를 활용해서 프로그램을 만드는 것을 객체 지향 프로그래밍이라 함. 이 패턴을 수많은 개발자들이 활용하자 프로그래밍 언어 개발자들이 프로그래밍 언어에 객체를 더 효율적으로 만들 수 있는 문법을
추가하기 시작함.
- 프로그래밍 언어 개발자들은 크게 클래스(class)와 프로토타입(prototype)이라는 2가지 문법으로 객체를 효율적으로 만들 수 있게 했음. 간단하게 구분하면 클래스는 객체를 만들 때 수많은 지원을 하는 대신 많은 제한을 거는
문법. 반면 프로토타입은 제한을 많이 하지 않지만, 대신 지원도 별로 하지 않는 문법.
- 현재 사용되는 대부분의 객체 지향 프로그래밍 언어는 클래스 문법 제공. js는 초기에 프로토타입 문법을 제공했지만 후에 클래스 문법을 제공하기 시작.
- 클래스는 다음과 같은 형태로 생성.
```js
class 클래스_이름 {
    
}
```
- 클래스를 기반으로 만든 객체를 전문 용어로 인스턴스(instance)라고 부름. 그냥 객체(object)라고 부르는 경우도 많음. 인스턴스를 생성할 때는 다음과 같은 문법을 사용함.
```js
new 클래스_이름()
```
- 클래스 : 이전에 살펴보았던 객체를 만드는 함수와 비슷한 것.
- 인스턴스(객체) : 이전에 만들었던 객체를 만드는 함수로 만든 객체와 비슷한 것.
- 클래스 선언하고 인스턴스 생성하기
```js
// 클래스를 선언함.
class Student {
    
}

// 학생을 선언함.
const student = new Student()

const students = [
  new Student(),
  new Student(),
  new Student(),
  new Student()
]
```
- 클래스 이름은 첫 글자를 대문자로 지정하는 것이 개발자들의 약속.

## 생성자
- new Student()처럼 Student 이름 뒤에 함수처럼 괄호를 열고 닫는 기호 존재. 이는 객체가 생성될 때 호출되는 생성자(constructor)라는 이름의 함수.
- 생성자는 다음과 같은 형태로 만듦. 메소드 이름을 constructor 로 지정했지만 constructor 라는 이름으로 사용하는 것이 아닌 클래스 이름으로 호출함.
```js
class 클래스_이름 {
    constructor() {
        // 생성자 코드
    }
}
```
- 생성자는 클래스를 기반으로 인스턴스를 생성할 때 처음 호출하는 메소드. 따라서 생성자에서는 속성을 추가하는 등 객체의 초기화 처리를 함.
- 생성자 함수와 속성 추가하기.
```js
class Student {
    constructor(이름, 국어, 영어, 수학, 과학) {
        this.이름 = 이름
        this.국어 = 국어
        this.영어 = 영어
        this.수학 = 수학
        this.과학 = 과학
    }
}

// 객체를 선언
const students = []
students.push(new Student('구름', 87, 98, 88, 90))
students.push(new Student('별이', 92, 98, 96, 88))
students.push(new Student('겨울', 76, 96, 94, 86))
students.push(new Student('바다', 98, 52, 98, 92))
```

## 메소드
- 메소드(method)는 다음과 같은 형태로 추가함. 이렇게 메소드를 만들면 내부적으로 메소드가 중복되지 않고 하나만 생성되어 활용됨.
```js
class Student {
    constructor(이름, 국어, 영어, 수학, 과학) {
        this.이름 = 이름
        this.국어 = 국어
        this.영어 = 영어
        this.수학 = 수학
        this.과학 = 과학
    }

    getSum() {
        return this.국어 + this.영어 + this.수학 + this.과학
    }

    getAverage() {
        return this.getSum() / 4
    }

    toString() {
        return `${this.이름}\t${this.getSum()}점\t${this.getAverage()}점\n`
    }
}

// 객체를 선언
const students = []
students.push(new Student('구름', 87, 98, 88, 90))
students.push(new Student('별이', 92, 98, 96, 88))
students.push(new Student('겨울', 76, 96, 94, 86))
students.push(new Student('바다', 98, 52, 98, 92))

// 출력
let output = '이름\t총점\t평균\n'
for (const s of students) {
    output += s.toString()
}
console.log(output)
```

## 핵심 정리
- 객체 지향 패러다임은 객체를 우선적으로 생각해서 프로그램을 만든다는 방법론을 의미함.
- 추상화는 프로그램에서 필요한 요소만을 사용해서 객체를 표현하는 것을 의미함.
- 클래스는 객체를 안전하고 효율적으로 만들 수 있게 해주는 문법.
- 인스턴스는 클래스를 기반으로 생성한 객체를 의미.
- 생성자는 클래스를 기반으로 인스턴스를 생성할 때 처음 호출되는 메소드.
